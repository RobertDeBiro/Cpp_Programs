@startuml Command_Pattern_Home_Automation

' Command Pattern - Home Automation Class Diagram
' Shows the separation between Invoker, Command, and Receiver

skinparam classAttributeIconSize 0
skinparam backgroundColor #FFFFFF
skinparam class {
    BackgroundColor<<invoker>> #FFE0B2
    BorderColor<<invoker>> #E65100
    BackgroundColor<<command>> #E1F5FE
    BorderColor<<command>> #01579B
    BackgroundColor<<receiver>> #C8E6C9
    BorderColor<<receiver>> #2E7D32
}

' ===== COMMAND INTERFACE =====

interface Command <<command>> {
    + {abstract} execute() : void
    + {abstract} undo() : void
    + ~Command()
}

' ===== CONCRETE COMMANDS =====

class LightOnCommand <<command>> {
    - light : Light*
    --
    + LightOnCommand(Light*)
    + execute() : void
    + undo() : void
}

class LightOffCommand <<command>> {
    - light : Light*
    --
    + LightOffCommand(Light*)
    + execute() : void
    + undo() : void
}

class StereoOnWithCDCommand <<command>> {
    - stereo : Stereo*
    --
    + StereoOnWithCDCommand(Stereo*)
    + execute() : void
    + undo() : void
}

class StereoOffCommand <<command>> {
    - stereo : Stereo*
    --
    + StereoOffCommand(Stereo*)
    + execute() : void
    + undo() : void
}

class NoCommand <<command>> {
    --
    + execute() : void
    + undo() : void
}

class MacroCommand <<command>> {
    - commands : vector<shared_ptr<Command>>
    --
    + MacroCommand(vector<shared_ptr<Command>>)
    + execute() : void
    + undo() : void
}

' ===== INVOKER =====

class RemoteControl <<invoker>> {
    - onCommands : array<shared_ptr<Command>, 7>
    - offCommands : array<shared_ptr<Command>, 7>
    - undoCommand : shared_ptr<Command>
    --
    + RemoteControl()
    + setCommand(slot : int, on : shared_ptr<Command>, off : shared_ptr<Command>) : void
    + onButtonWasPushed(slot : int) : void
    + offButtonWasPushed(slot : int) : void
    + undoButtonWasPushed() : void
    + toString() : string
}

' ===== RECEIVERS =====

class Light <<receiver>> {
    - location : string
    --
    + Light(location : string)
    + on() : void
    + off() : void
    + getLocation() : string
}

class Stereo <<receiver>> {
    - location : string
    --
    + Stereo(location : string)
    + on() : void
    + off() : void
    + setCD() : void
    + setDVD() : void
    + setRadio() : void
    + setVolume(volume : int) : void
    + getLocation() : string
}

' ===== RELATIONSHIPS =====

' Concrete commands implement Command interface
Command <|.. LightOnCommand
Command <|.. LightOffCommand
Command <|.. StereoOnWithCDCommand
Command <|.. StereoOffCommand
Command <|.. NoCommand
Command <|.. MacroCommand

' Invoker uses Command interface
RemoteControl o--> "14" Command : uses

' Concrete commands bind to Receivers
LightOnCommand --> Light : binds to >
LightOffCommand --> Light : binds to >
StereoOnWithCDCommand --> Stereo : binds to >
StereoOffCommand --> Stereo : binds to >

' MacroCommand aggregates other Commands
MacroCommand o--> "*" Command : contains

' ===== NOTES =====

note top of Command
  **Command Interface**

  Declares execute() and undo() methods.
  All concrete commands implement this.

  Key: Commands are OBJECTS that
  encapsulate requests.
end note

note right of LightOnCommand
  **Concrete Commands**

  - Bind a Receiver with an action
  - execute() invokes receiver's method
  - undo() reverses the action

  Example:
  execute() { light->on(); }
  undo() { light->off(); }
end note

note left of RemoteControl
  **Invoker**

  - Holds references to Command objects
  - Calls execute() when needed
  - Does NOT know about receivers
  - Depends only on Command interface

  Key: Invoker is decoupled from
  receiver implementations.
end note

note bottom of Light
  **Receivers**

  Know HOW to perform actual work.
  Commands delegate to receivers.

  Receivers are independent of
  command pattern - they just
  provide the actions.
end note

note right of NoCommand
  **Null Object Pattern**

  NoCommand does nothing.
  Used to initialize slots so
  we don't need nullptr checks.

  Benefits:
  - No null checks in invoker
  - Always safe to call execute()
end note

note left of MacroCommand
  **Composite Pattern**

  MacroCommand executes multiple
  commands in sequence.

  Use cases:
  - "Party Mode" (lights + stereo)
  - "Movie Mode" (dim + TV + blinds)
  - Batch operations

  undo() executes in REVERSE order
end note

note as N1
  **Command Pattern Flow**

  1. Client creates Receiver (Light)
  2. Client creates Command (LightOnCommand)
     and binds it to Receiver
  3. Client configures Invoker (RemoteControl)
     with Command
  4. User presses button
  5. Invoker calls: command->execute()
  6. Command calls: light->on()
  7. User presses undo
  8. Invoker calls: command->undo()
  9. Command calls: light->off()
end note

note as N2
  **Key Benefits**

  ✓ Decouples invoker from receiver
  ✓ Commands are first-class objects
    (can be stored, queued, logged)
  ✓ Undo/redo support built-in
  ✓ Macro commands (composite operations)
  ✓ Easy to add new commands
    (Open/Closed Principle)
  ✓ Testable (mock commands)
end note

note as N3
  **Participants**

  - **Command:** Declares interface
  - **ConcreteCommand:** Binds receiver
    with action
  - **Receiver:** Knows how to perform work
  - **Invoker:** Asks command to execute
  - **Client:** Creates and configures
    commands
end note

@enduml
