@startuml Adapter_Pattern_Duck_Turkey

' Adapter Pattern - Duck/Turkey Class Diagram
' Shows how Adapter makes incompatible interfaces work together

skinparam classAttributeIconSize 0
skinparam backgroundColor #FFFFFF
skinparam class {
    BackgroundColor<<target>> #C8E6C9
    BorderColor<<target>> #2E7D32
    BackgroundColor<<adapter>> #FFF9C4
    BorderColor<<adapter>> #F57F17
    BackgroundColor<<adaptee>> #E1F5FE
    BorderColor<<adaptee>> #01579B
}

' ===== CLIENT =====

class Client <<function>> {
    --
    + testDuck(duck : Duck*)
}

' ===== TARGET INTERFACE =====

interface Duck <<target>> {
    + {abstract} quack() : void
    + {abstract} fly() : void
    + ~Duck()
}

' ===== CONCRETE TARGET =====

class MallardDuck <<target>> {
    --
    + MallardDuck()
    + quack() : void
    + fly() : void
}

' ===== ADAPTER =====

class TurkeyAdapter <<adapter>> {
    - turkey : Turkey*
    --
    + TurkeyAdapter(turkey : Turkey*)
    + quack() : void
    + fly() : void
}

' ===== ADAPTEE INTERFACE =====

interface Turkey <<adaptee>> {
    + {abstract} gobble() : void
    + {abstract} fly() : void
    + ~Turkey()
}

' ===== CONCRETE ADAPTEE =====

class WildTurkey <<adaptee>> {
    --
    + WildTurkey()
    + gobble() : void
    + fly() : void
}

' ===== RELATIONSHIPS =====

' Client uses Target interface
Client ..> Duck : uses

' Concrete Target implements Target
Duck <|.. MallardDuck : implements

' Adapter implements Target
Duck <|.. TurkeyAdapter : implements

' Adapter holds reference to Adaptee
TurkeyAdapter o--> Turkey : adapts

' Concrete Adaptee implements Adaptee interface
Turkey <|.. WildTurkey : implements

' ===== NOTES =====

note top of Client
  **Client**

  Works only with Duck interface.
  Has no knowledge of Turkey or
  TurkeyAdapter.

  testDuck(Duck* duck) {
    duck->quack();
    duck->fly();
  }
end note

note right of Duck
  **Target Interface**

  The interface that client expects.
  Adapter must implement this
  interface to be usable by client.

  In this example:
  - quack() is the expected behavior
  - fly() is the expected behavior
end note

note left of TurkeyAdapter
  **Adapter**

  - Implements Target interface (Duck)
  - Holds reference to Adaptee (Turkey)
  - Translates Target calls to Adaptee calls

  Key Methods:
  quack() { turkey->gobble(); }
  fly() {
    for(i=0; i<5; i++)
      turkey->fly();
  }

  Note: Adapter doesn't just forward
  calls - it can adapt behavior too!
  (5 short turkey flights = 1 duck flight)
end note

note right of Turkey
  **Adaptee Interface**

  The incompatible interface we want
  to use with client code.

  Differences from Target:
  - gobble() instead of quack()
  - fly() has different behavior
    (short distance vs long distance)
end note

note bottom of WildTurkey
  **Concrete Adaptee**

  The actual class with incompatible
  interface that we want to adapt.

  Cannot modify this class:
  - Third-party library
  - Legacy code
  - Shared with other systems
end note

note as N1
  **Adapter Pattern Flow**

  1. Client calls: turkeyAdapter->quack()
  2. TurkeyAdapter::quack() translates to: turkey->gobble()
  3. WildTurkey::gobble() executes

  Client is completely unaware that
  it's actually calling a Turkey!
end note

note as N2
  **Key Benefits**

  ✓ Reuse existing code (Turkey)
    without modification
  ✓ Client code unchanged
  ✓ Open/Closed Principle
    (extend via new adapters)
  ✓ Single Responsibility
    (adapter handles only translation)
  ✓ Testability
    (can mock adapters)
end note

note as N3
  **Object Adapter (Composition)**

  This diagram shows Object Adapter,
  which uses composition:
  - Adapter HAS-A Turkey (holds reference)
  - Adapter IS-A Duck (implements interface)

  Alternative: Class Adapter
  (uses multiple inheritance):
  - class TurkeyAdapter : public Duck,
                          private Turkey
  - Less flexible, but can override
    adaptee methods
end note

note as N4
  **When to Use Adapter**

  ✓ Want to use existing class with
    incompatible interface
  ✓ Cannot modify existing class
    (third-party, legacy, shared)
  ✓ Want to create reusable class
    that cooperates with unrelated
    classes
  ✓ Need several subclasses with
    common interface
end note

@enduml
