@startuml Facade_Pattern_Home_Theater

' Facade Pattern - Home Theater System Class Diagram
' Shows how Facade simplifies interaction with complex subsystem

skinparam classAttributeIconSize 0
skinparam backgroundColor #FFFFFF
skinparam class {
    BackgroundColor<<client>> #E8F5E9
    BorderColor<<client>> #1B5E20
    BackgroundColor<<facade>> #FFF9C4
    BorderColor<<facade>> #F57F17
    BackgroundColor<<subsystem>> #E1F5FE
    BorderColor<<subsystem>> #01579B
}

' ===== CLIENT =====

class Client <<client>> {
    --
    + main()
}

' ===== FACADE =====

class HomeTheaterFacade <<facade>> {
    - amp : Amplifier*
    - tuner : Tuner*
    - dvd : DvdPlayer*
    - cd : CdPlayer*
    - projector : Projector*
    - screen : Screen*
    - lights : TheaterLights*
    - popper : PopcornPopper*
    --
    + HomeTheaterFacade(...)
    + watchMovie(movie : string) : void
    + endMovie() : void
    + listenToCd(cdTitle : string) : void
    + endCd() : void
    + listenToRadio(frequency : double) : void
    + endRadio() : void
}

' ===== SUBSYSTEM COMPONENTS =====

package "Complex Subsystem" {

    class Amplifier <<subsystem>> {
        - name : string
        --
        + on() : void
        + off() : void
        + setDvd(dvd : DvdPlayer*) : void
        + setCd(cd : CdPlayer*) : void
        + setTuner(tuner : Tuner*) : void
        + setSurroundSound() : void
        + setStereoSound() : void
        + setVolume(level : int) : void
    }

    class DvdPlayer <<subsystem>> {
        - name : string
        - currentMovie : string
        --
        + on() : void
        + off() : void
        + play(movie : string) : void
        + stop() : void
        + eject() : void
        + pause() : void
    }

    class CdPlayer <<subsystem>> {
        - name : string
        - currentCd : string
        --
        + on() : void
        + off() : void
        + play(cd : string) : void
        + stop() : void
        + eject() : void
        + pause() : void
    }

    class Projector <<subsystem>> {
        - name : string
        --
        + on() : void
        + off() : void
        + wideScreenMode() : void
        + tvMode() : void
    }

    class Screen <<subsystem>> {
        --
        + up() : void
        + down() : void
    }

    class TheaterLights <<subsystem>> {
        --
        + on() : void
        + off() : void
        + dim(level : int) : void
    }

    class PopcornPopper <<subsystem>> {
        --
        + on() : void
        + off() : void
        + pop() : void
    }

    class Tuner <<subsystem>> {
        - name : string
        - frequency : double
        --
        + on() : void
        + off() : void
        + setAm() : void
        + setFm() : void
        + setFrequency(freq : double) : void
    }
}

' ===== RELATIONSHIPS =====

' Client uses Facade
Client ..> HomeTheaterFacade : uses

' Facade composes subsystem components
HomeTheaterFacade o--> Amplifier : simplifies
HomeTheaterFacade o--> Tuner : simplifies
HomeTheaterFacade o--> DvdPlayer : simplifies
HomeTheaterFacade o--> CdPlayer : simplifies
HomeTheaterFacade o--> Projector : simplifies
HomeTheaterFacade o--> Screen : simplifies
HomeTheaterFacade o--> TheaterLights : simplifies
HomeTheaterFacade o--> PopcornPopper : simplifies

' ===== NOTES =====

note top of Client
  **Client**

  Without Facade:
  - Must know about 8 components
  - Must call 15+ methods
  - Must remember correct sequence
  - Tightly coupled to subsystem

  With Facade:
  - Calls 1 method: watchMovie()
  - Simple, clean code
  - Loosely coupled
end note

note right of HomeTheaterFacade
  **Facade**

  Provides simplified interface to
  complex subsystem:

  watchMovie(movie) {
    popper->on();
    popper->pop();
    lights->dim(10);
    screen->down();
    projector->on();
    projector->wideScreenMode();
    amp->on();
    amp->setDvd(dvd);
    amp->setSurroundSound();
    amp->setVolume(5);
    dvd->on();
    dvd->play(movie);
  }

  endMovie() {
    popper->off();
    lights->on();
    screen->up();
    projector->off();
    amp->off();
    dvd->stop();
    dvd->eject();
    dvd->off();
  }

  **Key Benefits:**
  • Hides subsystem complexity
  • Provides convenient methods
  • Follows Principle of Least Knowledge
  • Doesn't prevent direct subsystem access
end note

note bottom of Amplifier
  **Complex Subsystem**

  8 components with many methods:
  - Amplifier (8 methods)
  - DvdPlayer (6 methods)
  - CdPlayer (6 methods)
  - Projector (4 methods)
  - Screen (2 methods)
  - TheaterLights (3 methods)
  - PopcornPopper (3 methods)
  - Tuner (5 methods)

  Total: 37 methods to manage!

  Without Facade: Client must
  know all components and methods.

  With Facade: Client calls
  simple watchMovie() method.
end note

note as N1
  **Facade Pattern Flow**

  1. Client calls: homeTheater->watchMovie("Movie")
  2. Facade orchestrates subsystem:
     • Turns on popcorn popper
     • Dims lights
     • Lowers screen
     • Configures projector
     • Configures amplifier
     • Plays DVD
  3. Subsystem complexity hidden from client

  Client remains unaware of subsystem
  components and their complex interactions!
end note

note as N2
  **Key Benefits**

  ✓ Simplifies client code
    (1 method vs 15+ method calls)
  ✓ Hides subsystem complexity
    (client doesn't need to know details)
  ✓ Decouples client from subsystem
    (client depends only on facade)
  ✓ Principle of Least Knowledge
    (client talks only to facade)
  ✓ Doesn't prevent direct access
    (can still use subsystem if needed)
  ✓ Easy to add new facade methods
    (without modifying subsystem)
end note

note as N3
  **Facade vs Other Patterns**

  **Facade vs Adapter:**
  • Facade: Simplifies interface (many-to-1)
  • Adapter: Changes interface (1-to-1)

  **Facade vs Decorator:**
  • Facade: Simplifies (hides complexity)
  • Decorator: Enhances (adds behavior)

  **Facade vs Mediator:**
  • Facade: Unidirectional (client→facade→subsystem)
  • Mediator: Bidirectional (components communicate)
end note

note as N4
  **When to Use Facade**

  ✓ Want simple interface to complex subsystem
  ✓ Many dependencies between clients/subsystem
  ✓ Want to layer subsystems
  ✓ Want to decouple client from subsystem
  ✓ Subsystem has many classes/methods
  ✓ Want to improve readability/usability

  **Real-World Examples:**
  • Database connection pools
  • File system APIs
  • Compiler front-ends
  • Video conversion libraries
  • Game engine subsystems
end note

note as N5
  **Comparison: Without vs With Facade**

  **WITHOUT Facade (15+ method calls):**
  popper->on();
  popper->pop();
  lights->dim(10);
  screen->down();
  projector->on();
  projector->wideScreenMode();
  amp->on();
  amp->setDvd(dvd);
  amp->setSurroundSound();
  amp->setVolume(5);
  dvd->on();
  dvd->play("Movie");

  **WITH Facade (1 method call):**
  homeTheater->watchMovie("Movie");

  **Simplification:** 92% reduction in
  code complexity (15+ calls → 1 call)
end note

note as N6
  **Design Principle**

  **Principle of Least Knowledge**
  (Law of Demeter)

  "Talk only to your immediate friends"

  Without Facade:
  Client knows about 8 subsystem classes
  (Amplifier, DvdPlayer, Projector, etc.)

  With Facade:
  Client knows only about 1 class
  (HomeTheaterFacade)

  This reduces dependencies and makes
  the system more maintainable.
end note

@enduml
